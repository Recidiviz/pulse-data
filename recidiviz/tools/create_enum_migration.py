"""Script to generate an alembic migration for adding a new value to an enum

NOTE: The environment variables required by the alembic migration script must
be set before running this script

Usage:
    python create_enum_migration.py --master_table <master table name> \
        --historical_table <historical table name> --type <enum type name> \
        --column <column name> --migration_name <name for migration>

Example:
    python create_enum_migration.py --master_table person \
        --historical_table person_history --type race --column race \
        --migration_name add_race_lizardperson
"""

import argparse
import os


_PATH_TO_DATABASE_DIRECTORY = 'recidiviz/persistence/database'
_PATH_TO_VERSIONS_DIRECTORY = \
    _PATH_TO_DATABASE_DIRECTORY + '/migrations/versions'
_PATH_TO_BODY_SECTION_TEMPLATE = \
    _PATH_TO_DATABASE_DIRECTORY + '/migrations/enum_migration_template.txt'
_HEADER_SECTION_FINAL_LINE_START = 'depends_on'


def _create_new_migration_and_return_filename(migration_name):
    """Calls alembic script to generate new empty migration with
    |migration_name| and returns its filename"""
    current_directory = os.getcwd()
    initial_filenames = _get_all_filenames_in_versions_directory()

    # Temporarily change directory to database directory, since the alembic
    # script requires it
    os.chdir(_PATH_TO_DATABASE_DIRECTORY)
    os.system('alembic revision -m {}'.format(migration_name))

    os.chdir(current_directory)
    new_filenames = _get_all_filenames_in_versions_directory()

    # Versions directory should now have 1 new file
    return new_filenames.difference(initial_filenames).pop()


def _get_all_filenames_in_versions_directory():
    """Returns set of all filenames currently in versions directory"""
    return {item for item in os.listdir(_PATH_TO_VERSIONS_DIRECTORY)
            if os.path.isfile(os.path.join(_PATH_TO_VERSIONS_DIRECTORY, item))}


def _get_migration_header_section(migration_filepath):
    """Returns string of autogenerated header section of alembic migration
    containing version hash information
    """
    header_section_lines = []

    with open(migration_filepath, 'r') as migration_file:
        for line in migration_file.readlines():
            header_section_lines.append(line)
            if line.startswith(_HEADER_SECTION_FINAL_LINE_START):
                break

    return ''.join(header_section_lines)


def _get_migration_body_section(master_table_name, historical_table_name,
                                type_name, column_name):
    """Returns string of body section of enum migration by interpolating
    provided values into enum migration template
    """
    with open(_PATH_TO_BODY_SECTION_TEMPLATE, 'r') as template_file:
        template = template_file.read()
    return template.format(
        master_table=master_table_name,
        historical_table=historical_table_name,
        type=type_name,
        column=column_name)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--master_table')
    parser.add_argument('--historical_table')
    parser.add_argument('--type')
    parser.add_argument('--column')
    parser.add_argument('--migration_name')

    args = parser.parse_args()

    migration_filename = _create_new_migration_and_return_filename(
        args.migration_name)
    migration_filepath = os.path.join(
        _PATH_TO_VERSIONS_DIRECTORY, migration_filename)
    header_section = _get_migration_header_section(migration_filepath)
    body_section = _get_migration_body_section(
        args.master_table, args.historical_table, args.type, args.column)
    file_content = '{}\n{}'.format(header_section, body_section)

    with open(migration_filepath, 'w') as migration_file:
        migration_file.write(file_content)

    print('Successfully generated migration {}'.format(migration_filename))


if __name__ == '__main__':
    main()
