# Recidiviz - a data platform for criminal justice reform
# Copyright (C) 2025 Recidiviz, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# =============================================================================
"""Script to sync Looker LookML with pulse-data repository.

Intended to be run as a GitHub Action, this script automates the process of
syncing LookML files from a specific pull request in the pulse-data repository
to the Looker repository. It creates a new branch in the Looker repo, copies
the LookML files, commits the changes, and opens a pull request against the
specified base branch in the Looker repo.
"""
import argparse
import logging
from dataclasses import dataclass

import attr
from github import Auth, Github

from recidiviz.common import attr_validators
from recidiviz.tools.looker.copy_all_lookml import copy_all_autogenerated_lookml
from recidiviz.tools.looker.script_helpers import get_git_manager_for_temp_looker_repo
from recidiviz.tools.utils.git_manager import GitManager
from recidiviz.utils.github import (
    LOOKER_REPO_NAME,
    RECIDIVIZ_DATA_REPO,
    get_pr_if_exists,
    open_pr_if_not_exists,
    upsert_pr_comment,
)

AUTOGENERATED_BRANCH_PREFIX = "update-lookml-sync-"
AUTOGENERATED_MESSAGE_PREFIX = (
    f"[AUTOGENERATED] Automated sync from {RECIDIVIZ_DATA_REPO}"
)


@dataclass
class RecidivizDataLookerSyncConfig:
    """Configuration for the pulse-data to Looker sync process."""

    recidiviz_data_pr_number: int = attr.ib(validator=attr_validators.is_int)
    recidiviz_data_commit_sha: str = attr.ib(validator=attr_validators.is_str)
    # Base branch that pulse-data PR is targeting, which we will use to create the Looker PR against.
    # A branch of this name should already exist in both the Looker repo and the pulse-data repo.
    base_branch: str = attr.ib(validator=attr_validators.is_str)
    github_token: str = attr.ib(validator=attr_validators.is_str)
    looker_branch_name: str = attr.ib(validator=attr_validators.is_str)

    @classmethod
    def from_args(cls, args: argparse.Namespace) -> "RecidivizDataLookerSyncConfig":
        """Create RecidivizDataLookerSyncConfig from command line arguments."""
        return cls(
            recidiviz_data_pr_number=args.pr_number,
            recidiviz_data_commit_sha=args.commit_sha,
            base_branch=args.base_branch,
            github_token=args.github_token,
            looker_branch_name=f"{AUTOGENERATED_BRANCH_PREFIX}{args.pr_number}",
        )


class RecidivizDataLookerSyncGitHubManager:
    """Handles GitHub operations like creating PRs and comments."""

    next_steps_body = (
        "**Next steps:**\n"
        "- If the `LookML Validation` check is failing on the `Looker` PR, you need to fix any LookML errors"
        " and push those changes to the autogenerated `Looker` branch.\n"
        "- Once your `pulse-data` PR is approved and all checks are passing, approve and merge the `Looker` PR.\n"
        "- Then you can proceed to merge the `pulse-data` PR.\n\n"
        "**Important:** If the `Looker` PR is not merged before the `pulse-data` PR, "
        "the `Verify LookML autogenerated file contents match between repos` workflow will fail on merge."
        "\nIf the Looker branch gets in a bad state, you can close the Looker PR and rerun the `Refresh pulse-data to Looker sync pr`"
        " workflow to create a new branch and PR with the latest changes."
    )

    def __init__(self, config: RecidivizDataLookerSyncConfig):
        self.sync_config = config
        self.github_client = Github(auth=Auth.Token(config.github_token))

    def create_looker_pr_if_not_exists(self) -> str:
        """Create a pull request in the Looker repository based on |self.sync_config|, if one does not already exist."""
        return open_pr_if_not_exists(
            github_client=self.github_client,
            title=f"{AUTOGENERATED_MESSAGE_PREFIX}#{self.sync_config.recidiviz_data_pr_number}",
            body=(
                f"## This PR was created automatically by the sync script from {RECIDIVIZ_DATA_REPO} PR https://github.com/{RECIDIVIZ_DATA_REPO}/pull/{self.sync_config.recidiviz_data_pr_number}.\n\n"
                f"{self.next_steps_body}"
            ),
            head_branch_name=self.sync_config.looker_branch_name,
            base_branch_name=self.sync_config.base_branch,
            repo=LOOKER_REPO_NAME,
        )

    def upsert_recidiviz_data_pr_comment(self, looker_pr_url: str) -> None:
        """Upsert a comment to the original pulse-data PR with instructions."""
        comment_body = (
            f"## Looker repo PR\n"
            f"[This PR]({looker_pr_url}) contains updates to LookML files "
            f"generated from your changes in `pulse-data`.\n\n"
            f"{self.next_steps_body}"
        )

        upsert_pr_comment(
            github_client=self.github_client,
            pull_request_number=self.sync_config.recidiviz_data_pr_number,
            body=comment_body,
            prefix="## Looker repo PR",
        )

    def pr_exists_for_branch(self, looker_branch_name: str) -> bool:
        """Check if an open PR exists for the given Looker branch."""
        return (
            get_pr_if_exists(
                github_client=self.github_client,
                head_branch_name=looker_branch_name,
                base_branch_name=self.sync_config.base_branch,
                repo=LOOKER_REPO_NAME,
            )
            is not None
        )


@attr.define
class RecidivizDataLookerSyncOrchestrator:
    """Main orchestrator for the pulse-data -> looker repo sync process."""

    sync_config: RecidivizDataLookerSyncConfig = attr.ib(
        validator=attr.validators.instance_of(RecidivizDataLookerSyncConfig)
    )
    git_manager: GitManager = attr.ib(validator=attr.validators.instance_of(GitManager))
    github_manager: RecidivizDataLookerSyncGitHubManager = attr.ib(
        validator=attr.validators.instance_of(RecidivizDataLookerSyncGitHubManager)
    )

    @classmethod
    def from_config(
        cls, config: RecidivizDataLookerSyncConfig
    ) -> "RecidivizDataLookerSyncOrchestrator":
        return cls(
            config,
            get_git_manager_for_temp_looker_repo(github_token=config.github_token),
            RecidivizDataLookerSyncGitHubManager(config),
        )

    def refresh_recidiviz_data_to_looker_sync_pr(self) -> None:
        """Opens a PR that will refresh pulse-data generated LookML in the Recidiviz/looker repo,
        or refreshes the existing PR if one already exists."""
        logging.info(
            "Starting Looker sync for PR #%s", self.sync_config.recidiviz_data_pr_number
        )

        # If there is an existing open Looker PR, we will reuse the branch.
        # Otherwise, we will delete the branch if it exists and create a new one.
        # This way if things get in a bad state, users can close the Looker PR and rerun the script.
        if not self.github_manager.pr_exists_for_branch(
            self.sync_config.looker_branch_name
        ):
            self.git_manager.delete_branch_if_exists(
                self.sync_config.looker_branch_name
            )

        self.git_manager.create_branch_if_not_exists(
            base_branch_name=self.sync_config.base_branch,
            new_branch_name=self.sync_config.looker_branch_name,
        )

        copy_all_autogenerated_lookml(str(self.git_manager.repo_root))

        if self.git_manager.has_uncommitted_changes():
            self.git_manager.commit_and_push_all_changes(
                commit_msg=f"{AUTOGENERATED_MESSAGE_PREFIX}@{self.sync_config.recidiviz_data_commit_sha}"
            )

        if self.git_manager.remote_branch_exists(self.sync_config.looker_branch_name):
            looker_pr_url = self.github_manager.create_looker_pr_if_not_exists()
            self.github_manager.upsert_recidiviz_data_pr_comment(looker_pr_url)
            logging.info("Finished sync. Looker PR: %s", looker_pr_url)
        else:
            logging.info("No changes to commit.")


def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Sync Looker LookML with pulse-data."
    )
    parser.add_argument(
        "--pr-number",
        type=int,
        required=True,
        help="pulse-data pull request number.",
    )
    parser.add_argument(
        "--base-branch",
        type=str,
        required=True,
        help="Base branch to create the Looker PR against. "
        "A branch of this name should already exist in both the Looker repo and the pulse-data repo.",
    )
    parser.add_argument(
        "--github-token",
        type=str,
        required=True,
        help="GitHub token with looker and pulse-data repo access.",
    )
    parser.add_argument(
        "--commit-sha",
        type=str,
        required=True,
        help="The most recent commit SHA of the pulse-data PR to sync from.",
    )
    return parser.parse_args()


def main() -> None:
    """Main entry point for the script."""
    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
    )

    config = RecidivizDataLookerSyncConfig.from_args(args=parse_arguments())

    RecidivizDataLookerSyncOrchestrator.from_config(
        config
    ).refresh_recidiviz_data_to_looker_sync_pr()


if __name__ == "__main__":
    main()
