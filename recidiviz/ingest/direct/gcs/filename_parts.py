# Recidiviz - a data platform for criminal justice reform
# Copyright (C) 2022 Recidiviz, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# =============================================================================
"""Helpers for parsing normalized ingest GCS file names into their constituent parts."""
import datetime
import re
from typing import Optional

import attr

from recidiviz.cloud_storage.gcsfs_path import GcsfsFilePath
from recidiviz.ingest.direct.gcs.file_type import GcsfsDirectIngestFileType
from recidiviz.ingest.direct.types.errors import (
    DirectIngestError,
    DirectIngestErrorType,
)

_INGEST_FILE_PREFIX_REGEX_PATTERN = (
    r"(?P<processed_state>unprocessed|processed)_"  # processed_state
    r"(?P<timestamp>\d{4}-\d{2}-\d{2}T\d{2}[:_]\d{2}[:_]\d{2}[:_]\d{6})_"  # timestamp
    r"((?P<file_type>raw|ingest_view)_)"  # file_type
)
_INGEST_FILE_SUFFIX_REGEX_PATTERN = (
    r"(?P<filename_suffix_conflict>-\(\d+\))?"  # Optional file conflict suffix (e.g. '-(1)')
    r"\.(?P<extension>[A-Za-z]+)$"  # Extension
)
_INGEST_FILE_TYPE_REGEX = re.compile(_INGEST_FILE_PREFIX_REGEX_PATTERN)
_RAW_DATA_FILE_NAME_REGEX = re.compile(
    _INGEST_FILE_PREFIX_REGEX_PATTERN
    + r"(?P<file_tag>[A-Za-z][A-Za-z\d]*(_[A-Za-z\d]*)*)"  # file_tag
    + _INGEST_FILE_SUFFIX_REGEX_PATTERN
)
_INGEST_VIEW_FILE_NAME_REGEX = re.compile(
    _INGEST_FILE_PREFIX_REGEX_PATTERN
    + r"(?P<file_tag>[A-Za-z][A-Za-z\d]*(_[A-Za-z][A-Za-z\d]*)*)"  # file_tag
    r"(_(?P<filename_suffix>\d+([^-]*)))?"  # Optional filename_suffix
    + _INGEST_FILE_SUFFIX_REGEX_PATTERN
)
_FILENAME_SUFFIX_REGEX = re.compile(
    r".*(_file_split(_size(?P<file_split_size_str>\d+))?)$"
)


@attr.s(frozen=True)
class GcsfsFilenameParts:
    """A convenience struct that contains information about a file parsed from
    a filename that has been generated by
    cloud_function_utils.py::to_normalized_unprocessed_file_path().

    E.g. Consider the following file path
    "/processed_2019-08-14T23:09:27:047747_elite_offenders_019_historical.csv"

    This will be parsed by filename_parts_from_path() to:
    utc_upload_datetime=datetime.fromisoformat(2019-08-14T23:09:27:047747)
    date_str="2019-08-14"
    file_tag="elite_offenders"
    filename_suffix="019_historical"
    extension="csv"
    """

    processed_state: str = attr.ib()
    utc_upload_datetime: datetime.datetime = attr.ib()
    utc_upload_datetime_str: str = attr.ib()
    date_str: str = attr.ib()
    file_type: GcsfsDirectIngestFileType = attr.ib()
    # May contain letters, numbers, and the '_' char. If it contains numbers trailing an _, it must be a RAW_DATA file type.
    file_tag: str = attr.ib()
    # Must start a number and be separated from the file_tag by a '_' char.
    filename_suffix: Optional[str] = attr.ib()
    extension: str = attr.ib()
    is_file_split: bool = attr.ib()
    file_split_size: Optional[int] = attr.ib()

    # File tag followed by file suffix, if there is one
    stripped_file_name: str = attr.ib()

    @stripped_file_name.default
    def _stripped_file_name(self) -> str:
        suffix_str = f"_{self.filename_suffix}" if self.filename_suffix else ""
        return f"{self.file_tag}{suffix_str}"


def _filename_parts_from_raw_data_path(file_path: GcsfsFilePath) -> GcsfsFilenameParts:
    """Parses filename for RAW_DATA file types"""
    match = re.match(_RAW_DATA_FILE_NAME_REGEX, file_path.file_name)

    if not match:
        raise DirectIngestError(
            msg=f"Could not parse upload_ts, file_tag, extension "
            f"from path [{file_path.abs_path()}]",
            error_type=DirectIngestErrorType.INPUT_ERROR,
        )

    full_upload_timestamp_str = match.group("timestamp")
    utc_upload_datetime = datetime.datetime.fromisoformat(full_upload_timestamp_str)
    file_type = GcsfsDirectIngestFileType.from_string(match.group("file_type"))

    return GcsfsFilenameParts(
        processed_state=match.group("processed_state"),
        utc_upload_datetime=utc_upload_datetime,
        utc_upload_datetime_str=full_upload_timestamp_str,
        date_str=utc_upload_datetime.date().isoformat(),
        file_type=file_type,
        file_tag=match.group("file_tag"),
        extension=match.group("extension"),
        is_file_split=False,
        file_split_size=None,
        filename_suffix=None,
    )


def _filename_parts_from_ingest_view_path(
    file_path: GcsfsFilePath,
) -> GcsfsFilenameParts:
    """Parses filename for INGEST_VIEW file types"""
    match = re.match(_INGEST_VIEW_FILE_NAME_REGEX, file_path.file_name)

    if not match:
        raise DirectIngestError(
            msg=f"Could not parse upload_ts, file_tag, extension "
            f"from path [{file_path.abs_path()}]",
            error_type=DirectIngestErrorType.INPUT_ERROR,
        )

    full_upload_timestamp_str = match.group("timestamp")
    utc_upload_datetime = datetime.datetime.fromisoformat(full_upload_timestamp_str)
    file_type = GcsfsDirectIngestFileType.from_string(match.group("file_type"))

    filename_suffix = match.group("filename_suffix")
    is_file_split = False
    file_split_size = None

    if filename_suffix:
        filename_suffix_file_split_match = re.match(
            _FILENAME_SUFFIX_REGEX, filename_suffix
        )
        if filename_suffix_file_split_match is not None:
            is_file_split = True
            file_split_size_str = filename_suffix_file_split_match.group(
                "file_split_size_str"
            )
            file_split_size = int(file_split_size_str) if file_split_size_str else None

    return GcsfsFilenameParts(
        processed_state=match.group("processed_state"),
        utc_upload_datetime=utc_upload_datetime,
        utc_upload_datetime_str=full_upload_timestamp_str,
        date_str=utc_upload_datetime.date().isoformat(),
        file_type=file_type,
        file_tag=match.group("file_tag"),
        extension=match.group("extension"),
        is_file_split=is_file_split,
        file_split_size=file_split_size,
        filename_suffix=filename_suffix,
    )


def filename_parts_from_path(file_path: GcsfsFilePath) -> GcsfsFilenameParts:
    match = re.match(_INGEST_FILE_TYPE_REGEX, file_path.file_name)

    if not match:
        raise DirectIngestError(
            msg=f"Could not parse upload_ts, file_tag, extension "
            f"from path [{file_path.abs_path()}]",
            error_type=DirectIngestErrorType.INPUT_ERROR,
        )

    file_type = GcsfsDirectIngestFileType.from_string(match.group("file_type"))

    if file_type is GcsfsDirectIngestFileType.RAW_DATA:
        return _filename_parts_from_raw_data_path(file_path)

    if file_type is GcsfsDirectIngestFileType.INGEST_VIEW:
        return _filename_parts_from_ingest_view_path(file_path)

    raise DirectIngestError(
        msg=f"Unknown file_type {file_type}, must be one of: {GcsfsDirectIngestFileType.RAW_DATA} "
        f"or {GcsfsDirectIngestFileType.INGEST_VIEW}",
        error_type=DirectIngestErrorType.INPUT_ERROR,
    )
