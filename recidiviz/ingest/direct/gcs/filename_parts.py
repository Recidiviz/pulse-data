# Recidiviz - a data platform for criminal justice reform
# Copyright (C) 2022 Recidiviz, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# =============================================================================
"""Helpers for parsing normalized ingest GCS file names into their constituent parts."""
import datetime
import re
from typing import Optional

import attr

from recidiviz.cloud_storage.gcsfs_path import GcsfsFilePath
from recidiviz.ingest.direct.types.errors import (
    DirectIngestError,
    DirectIngestErrorType,
)

_INGEST_FILE_PREFIX_REGEX_PATTERN = (
    r"(?P<processed_state>unprocessed|processed)_"  # processed_state
    r"(?P<timestamp>\d{4}-\d{2}-\d{2}T\d{2}[:_]\d{2}[:_]\d{2}[:_]\d{6})_"  # timestamp
    r"raw_"  # file_type
)
_INGEST_FILE_SUFFIX_REGEX_PATTERN = (
    r"(?P<filename_suffix_conflict>-\(\d+\))?"  # Optional file conflict suffix (e.g. '-(1)')
    r"\.(?P<extension>[A-Za-z]+)$"  # Extension
)
_RAW_DATA_FILE_NAME_REGEX = re.compile(
    _INGEST_FILE_PREFIX_REGEX_PATTERN
    + r"(?P<file_tag>[A-Za-z][A-Za-z\d]*(_[A-Za-z\d]*)*)"  # file_tag
    r"(-(?P<filename_suffix>\d+))?"  # Optional filename_suffix
    + _INGEST_FILE_SUFFIX_REGEX_PATTERN
)


@attr.s(frozen=True)
class DirectIngestRawFilenameParts:
    """A convenience struct that contains information about a raw data file parsed from
    a filename that has been generated by
    cloud_function_utils.py::to_normalized_unprocessed_file_path().

    E.g. Consider the following file path
    "/processed_2019-08-14T23:09:27:047747_raw_elite_offenders_019_historical.csv"

    This will be parsed by filename_parts_from_path() to:
    utc_upload_datetime=datetime.fromisoformat(2019-08-14T23:09:27:047747)
    date_str="2019-08-14"
    file_tag="elite_offenders"
    filename_suffix="019_historical"
    extension="csv"
    """

    processed_state: str = attr.ib()
    utc_upload_datetime: datetime.datetime = attr.ib()
    utc_upload_datetime_str: str = attr.ib()
    date_str: str = attr.ib()
    # May contain letters, numbers, and the '_' char. If it contains numbers trailing an _, it must be a RAW_DATA file type.
    file_tag: str = attr.ib()
    # Must start a number and be separated from the file_tag by a '-' char.
    filename_suffix: Optional[str] = attr.ib()
    extension: str = attr.ib()

    # File tag followed by file suffix, if there is one
    stripped_file_name: str = attr.ib()

    @stripped_file_name.default
    def _stripped_file_name(self) -> str:
        suffix_str = f"-{self.filename_suffix}" if self.filename_suffix else ""
        return f"{self.file_tag}{suffix_str}"


def _filename_parts_from_raw_data_path(
    file_path: GcsfsFilePath,
) -> DirectIngestRawFilenameParts:
    """Parses filename for RAW_DATA file types"""
    match = re.match(_RAW_DATA_FILE_NAME_REGEX, file_path.file_name)

    if not match:
        raise DirectIngestError(
            msg=f"Could not parse upload_ts, file_tag, extension "
            f"from path [{file_path.abs_path()}]",
            error_type=DirectIngestErrorType.INPUT_ERROR,
        )

    full_upload_timestamp_str = match.group("timestamp")
    utc_upload_datetime = datetime.datetime.fromisoformat(full_upload_timestamp_str)

    return DirectIngestRawFilenameParts(
        processed_state=match.group("processed_state"),
        utc_upload_datetime=utc_upload_datetime,
        utc_upload_datetime_str=full_upload_timestamp_str,
        date_str=utc_upload_datetime.date().isoformat(),
        file_tag=match.group("file_tag"),
        extension=match.group("extension"),
        filename_suffix=match.group("filename_suffix"),
    )


def filename_parts_from_path(file_path: GcsfsFilePath) -> DirectIngestRawFilenameParts:
    match = re.match(_RAW_DATA_FILE_NAME_REGEX, file_path.file_name)

    if not match:
        raise DirectIngestError(
            msg=f"Could not parse upload_ts, file_tag, extension "
            f"from path [{file_path.abs_path()}]",
            error_type=DirectIngestErrorType.INPUT_ERROR,
        )

    full_upload_timestamp_str = match.group("timestamp")
    utc_upload_datetime = datetime.datetime.fromisoformat(full_upload_timestamp_str)

    return DirectIngestRawFilenameParts(
        processed_state=match.group("processed_state"),
        utc_upload_datetime=utc_upload_datetime,
        utc_upload_datetime_str=full_upload_timestamp_str,
        date_str=utc_upload_datetime.date().isoformat(),
        file_tag=match.group("file_tag"),
        extension=match.group("extension"),
        filename_suffix=match.group("filename_suffix"),
    )
