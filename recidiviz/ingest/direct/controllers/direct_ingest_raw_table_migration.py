# Recidiviz - a data platform for criminal justice reform
# Copyright (C) 2021 Recidiviz, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# =============================================================================
"""Utility classes for defining migrations on our direct ingest raw data tables."""

import abc
import datetime
import os
import re
from typing import List, Dict, Tuple

from recidiviz.utils import metadata

RAW_DATA_SUBDIR = 'raw_data'
MIGRATIONS_SUBDIR = 'migrations'
RAW_TABLE_MIGRATION_FILE_PREFIX = 'migrations_'


class RawTableMigration:
    """Base class for generating migration queries for a given raw data table."""

    def __init__(
            self,
            migrations_file: str,
            file_update_datetimes: List[datetime.datetime],
            filters: List[Tuple[str, str]]
    ):
        """
        Args:
            migrations_file: The path of the file where this migration is defined, used to derive the raw table region
                and file tag. Expected to end with /{region_code}/raw_data/migrations/migrations_{file_tag}.py.
            file_update_datetimes: List of datetimes corresponding to the update_datetime values for the raw data rows
                we want to change.
            filters: List of (column name, value) tuples that will be translated to filter statements in the
                WHERE clause of the migration query.
        """
        self.file_update_datetimes = file_update_datetimes
        self.file_tag = self._file_tag_from_migrations_file(migrations_file)
        self.filters = filters
        self._region_code_lower = self._region_code_lower_from_migrations_file(migrations_file)
        self._filter_clause = " AND ".join([f"{field} = '{value}'" for field, value in filters])

        self._validate_column_value_list('filters', filters)

    def migration_queries_by_update_datetime(self) -> Dict[datetime.datetime, str]:
        """Returns a map of migration queries, indexed by the update datetime for that migration. This map can be used
        to find queries to run for a given raw data file that has been just uploaded to BQ.
        """
        return {update_datetime: self._migration_query_for_update_datetime(update_datetime)
                for update_datetime in self.file_update_datetimes}

    @classmethod
    def print_list(cls, migrations: List['RawTableMigration']) -> None:
        """Prints out all queries generated by the migration objects in this list. For use in debugging and to generate
        migrations that need to be run on data that has already been imported to BQ.
        """
        print(f'/**************************** {metadata.project_id()} ****************************/')
        for migration in migrations:
            for query in migration.migration_queries_by_update_datetime().values():
                print(query)

    @property
    def _raw_table(self) -> str:
        """Returns the BQ raw table for this migration. Must be calculated dynamically rather than in the constructor
        because these migrations can be defined as top-level vars where the project_id is not yet available.
        """
        return f'{metadata.project_id()}.{self._region_code_lower}_raw_data.{self.file_tag}'

    @abc.abstractmethod
    def _migration_query_for_update_datetime(self, file_update_datetime: datetime.datetime) -> str:
        """Builds a migration query string to modify rows with the given update datetime. Should be implemented by
        subclasses based on the query type.
        """

    @staticmethod
    def _validate_column_value_list(list_name: str, col_value_list: List) -> None:
        if not isinstance(col_value_list, list):
            raise ValueError(f'Unexpected value type [{type(col_value_list)}] for [{list_name}].')

        column_names = {col for col, _value in col_value_list}

        if len(column_names) < len(col_value_list):
            raise ValueError(f'Found duplicated columns in [{list_name}]: {col_value_list}')

    @staticmethod
    def _file_tag_from_migrations_file(migrations_file: str) -> str:
        file_name, _ext = os.path.splitext(os.path.basename(migrations_file))
        if not file_name.startswith(RAW_TABLE_MIGRATION_FILE_PREFIX):
            raise ValueError(f'Unexpected migrations file name [{file_name}]')
        file_tag = file_name[len(RAW_TABLE_MIGRATION_FILE_PREFIX):]
        return file_tag

    @staticmethod
    def _region_code_lower_from_migrations_file(migrations_file: str) -> str:
        path_parts = os.path.normpath(migrations_file).split(os.sep)
        region_code, raw_data_dir, migrations_dir_name, _file_name = path_parts[-4:]
        if (raw_data_dir, migrations_dir_name) != (RAW_DATA_SUBDIR, MIGRATIONS_SUBDIR):
            raise ValueError(f'Unexpected path parts: {(raw_data_dir, migrations_dir_name)}')
        if not re.match(r'us_[a-z]{2}(_[a-z_]+)?', region_code):
            raise ValueError(f'Unexpected region code: {region_code}')
        return region_code


class UpdateRawTableMigration(RawTableMigration):
    """Class for generating UPDATE migration queries for a given raw data table."""

    UPDATE_MIGRATION_TEMPLATE = \
        """UPDATE `{raw_table}` SET {update_clause} WHERE update_datetime = '{update_datetime}' AND {filter_clause};"""

    def __init__(
        self,
        migrations_file: str,
        file_update_datetimes: List[datetime.datetime],
        filters: List[Tuple[str, str]],
        updates: List[Tuple[str, str]]
    ):
        super().__init__(migrations_file, file_update_datetimes, filters)
        self._validate_column_value_list('updates', updates)
        self.updates = updates
        self._update_clause = ", ".join([f"{field} = '{value}'" for field, value in updates])

    def _migration_query_for_update_datetime(self, file_update_datetime: datetime.datetime) -> str:
        return self.UPDATE_MIGRATION_TEMPLATE.format(
            raw_table=self._raw_table,
            update_datetime=file_update_datetime.isoformat(),
            update_clause=self._update_clause,
            filter_clause=self._filter_clause,
        )


class DeleteFromRawTableMigration(RawTableMigration):
    """Class for generating DELETE FROM migration queries for a given raw data table."""

    DELETE_FROM_MIGRATION_TEMPLATE = \
        """DELETE FROM `{raw_table}` WHERE update_datetime = '{update_datetime}' AND {filter_clause};"""

    def _migration_query_for_update_datetime(self, file_update_datetime: datetime.datetime) -> str:
        return self.DELETE_FROM_MIGRATION_TEMPLATE.format(
            project_id=metadata.project_id(),
            raw_table=self._raw_table,
            update_datetime=file_update_datetime.isoformat(),
            filter_clause=self._filter_clause,
        )
