# Recidiviz - a data platform for criminal justice reform
# Copyright (C) 2019 Recidiviz, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# =============================================================================

"Utils to be shared across recidiviz project"
import datetime
import itertools
import logging
import random
import time
import uuid
from typing import Any, Callable, Iterable, Optional, Set, Tuple, Type, TypeVar

import flask
from google.api_core import exceptions  # pylint: disable=no-name-in-module

from recidiviz.utils import environment
from recidiviz.utils.types import T

GENERATED_ID_SUFFIX = "_GENERATE"
RETRY_SLEEP = 30
DELIMITER = ":"


def create_generated_id() -> str:
    return str(uuid.uuid4()) + GENERATED_ID_SUFFIX


def is_generated_id(id_str: Optional[str]) -> bool:
    return id_str is not None and id_str.endswith(GENERATED_ID_SUFFIX)


def create_synthetic_id(*, external_id: str, id_type: str) -> str:
    """Returns a string that contains both information from the provided
    |external_id| and |id_type|.
    """
    return id_type + DELIMITER + external_id


def get_external_id(*, synthetic_id: str) -> str:
    """From a string generated by the above create_synthetic_id, extracts the
    external_id.
    """
    return DELIMITER.join(synthetic_id.split(DELIMITER)[1:])


def get_trace_id_from_flask() -> Optional[str]:
    """Get trace_id from flask request headers."""
    if flask is None or not flask.request:
        return None

    header = flask.request.headers.get("X_CLOUD_TRACE_CONTEXT")

    if header is None:
        return None

    trace_id = header.split("/", 1)[0]

    return trace_id


ReturnType = TypeVar("ReturnType")


def retry_grpc(
    num_retries: int, fn: Callable[..., ReturnType], *args: Any, **kwargs: Any
) -> ReturnType:
    """Retries a function call some number of times"""
    time_to_sleep = random.uniform(5, RETRY_SLEEP)
    for i in range(num_retries + 1):
        try:
            return fn(*args, **kwargs)
        except exceptions.ServerError as e:
            if i == num_retries:
                raise
            if "GOAWAY" in str(e) or "Deadline Exceeded" in str(e):
                logging.exception("Received exception: ")
                if environment.in_gcp():
                    logging.warning("Sleeping %.2f seconds and retrying", time_to_sleep)
                    time.sleep(time_to_sleep)
                    continue
            else:
                raise
    raise exceptions.ServiceUnavailable(
        f"Function unsuccessful {num_retries + 1} times"
    )


def check_all_objs_have_type(objs: Iterable[Any], expected_type: Type) -> None:
    if not all(isinstance(o, expected_type) for o in objs):
        raise ValueError(f"Not all objects are type [{expected_type.__name__}]")


def date_intersects_with_span(
    *, point_in_time: datetime.date, start_date: datetime.date, end_date: datetime.date
) -> bool:
    """Returns true if the provided |point_in_time| is within [start_date, end_date)"""
    return start_date <= point_in_time < end_date


def date_spans_overlap_exclusive(
    *,
    start_1: datetime.date,
    end_1: datetime.date,
    start_2: datetime.date,
    end_2: datetime.date,
) -> bool:
    """Returns true if the provided spans overlap. Spans which share a single date are not considered overlapping.

    The only exception to this is if one of the provided spans actually has the same start/end date.
    In this case, the spans are considered overlapping if the single-date span is within [start_date, end_date) of the
    other span.
    """
    if start_1 == end_1:
        return date_intersects_with_span(
            point_in_time=start_1, start_date=start_2, end_date=end_2
        )
    if start_2 == end_2:
        return date_intersects_with_span(
            point_in_time=start_2, start_date=start_1, end_date=end_1
        )
    return start_1 < end_2 and end_1 > start_2


def date_spans_overlap_inclusive(
    *,
    start_1: datetime.date,
    end_1: datetime.date,
    start_2: datetime.date,
    end_2: datetime.date,
) -> bool:
    """Returns true if the provided spans overlap. Spans which share a single date are considered overlapping."""
    return start_1 <= end_2 and end_1 >= start_2


def bidirectional_set_difference(set1: Set[T], set2: Set[T]) -> Tuple[Set[T], Set[T]]:
    """Returns a tuple containing (set1 - set2, set2 - set1)."""
    return set1.difference(set2), set2.difference(set1)


def pairwise(iterable: Iterable[Any]) -> Iterable[Any]:
    """
    Iterate over the elements in |iterable| in pairs (aka a sliding window of
    size 2).

    Example: s -> (s0,s1), (s1,s2), (s2, s3), ...
    """
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)


def convert_nested_dictionary_keys(
    data: dict[str, Any], convert_function: Callable
) -> dict[str, Any]:
    """
    Convert keys of a nested dictionary from one convention to another.
    """
    converted_dict = {}
    for key, value in data.items():
        converted_value = value
        if isinstance(value, dict):
            converted_value = convert_nested_dictionary_keys(value, convert_function)
        elif isinstance(value, list):
            converted_value = []
            for list_item in value:
                if isinstance(list_item, dict):
                    converted_value.append(
                        convert_nested_dictionary_keys(list_item, convert_function)
                    )
                else:
                    converted_value.append(list_item)
        converted_dict[convert_function(key)] = converted_value
    return converted_dict
