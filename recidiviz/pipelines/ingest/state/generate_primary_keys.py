# Recidiviz - a data platform for criminal justice reform
# Copyright (C) 2023 Recidiviz, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# =============================================================================
"""Utility function for generating primary keys from external id(s)."""
import json
from hashlib import sha256
from typing import List, Set, Union, cast

from recidiviz.big_query.big_query_utils import MAX_BQ_INT
from recidiviz.common.attr_mixins import attr_field_referenced_cls_name_for_field_name
from recidiviz.common.constants.states import StateCode
from recidiviz.persistence.entity.base_entity import (
    CoreEntity,
    Entity,
    ExternalIdEntity,
    HasExternalIdEntity,
    RootEntity,
)
from recidiviz.persistence.entity.entity_utils import (
    CoreEntityFieldIndex,
    EntityFieldType,
)
from recidiviz.persistence.entity.state.entities import StatePerson, StateStaff
from recidiviz.pipelines.ingest.state.constants import ExternalIdKey, PrimaryKey
from recidiviz.pipelines.ingest.state.serialize_entities import (
    serialize_entity_into_json,
)
from recidiviz.utils.types import assert_type, non_optional


def generate_primary_key(str_rep: str, state_code: StateCode) -> PrimaryKey:
    """Generate a primary key from a set of external ids. We first generate a hex digest
    from the SHA256 hash of the string representation of external IDs. We then take the
    first 56 bits of the 64bit integer representation of the hex digest. Then, we apply
    a mask with the state fips code.

    The primary key hash collision probability is generated by the following formula:
        probability_of_hash_collision = 1 - e^(-k(k-1)/2^56) wher k is the number of elements.
        For k = 30000000, the probability of a hash collision is ~1%.
    """
    int_64_bits = generate_64_int_from_hex_digest(str_rep)
    # Shift down 8 bits to create a 56 bit integer
    int_56_bits = int_64_bits >> 8
    # Generate integer that is fips code with 17 0s trailing (a 56 bit integer is no
    # longer than 17 decimal places).
    fips_code_mask = state_code.get_state_fips_mask(places=17)
    primary_key = fips_code_mask + int_56_bits
    if primary_key > MAX_BQ_INT:
        raise ValueError(
            f"Primary key {primary_key} is greater than the maximum integer supported by BigQuery"
        )
    return fips_code_mask + int_56_bits


def generate_64_int_from_hex_digest(str_rep: str) -> int:
    """Generate a 64 bit integer from a hex digest."""
    hex_digest_64_bits = sha256(str_rep.encode()).hexdigest()[
        :16
    ]  # 16 hex chars = 64-bits
    return int.from_bytes(bytes.fromhex(hex_digest_64_bits), "little")


def string_representation(external_id_keys: Set[ExternalIdKey]) -> str:
    """Get a string representation of a set of external ids."""
    return ",".join(
        sorted(
            _string_representation_of_key(external_id_key)
            for external_id_key in external_id_keys
        )
    )


def _string_representation_of_key(external_id_key: ExternalIdKey) -> str:
    external_id, external_id_type = external_id_key
    return f"{external_id_type}|{external_id}"


def generate_primary_keys_for_root_entity_tree(
    root_primary_key: PrimaryKey, root_entity: RootEntity, state_code: StateCode
) -> RootEntity:
    """Generate primary keys for a root entity tree by doing a Queue BFS traversal of the tree."""
    field_index = CoreEntityFieldIndex()

    queue: List[Union[RootEntity, Entity]] = [root_entity]

    while queue:
        entity = cast(Entity, queue.pop(0))
        if isinstance(entity, (StatePerson, StateStaff)):
            entity.set_id(root_primary_key)
        elif isinstance(entity, HasExternalIdEntity):
            external_id = assert_type(entity.get_external_id(), str)
            entity.set_id(
                generate_primary_key(
                    string_representation(
                        {
                            (
                                external_id,
                                entity.get_class_id_name(),
                            )
                        }
                    ),
                    state_code,
                ),
            )
        elif isinstance(entity, ExternalIdEntity):
            entity.set_id(
                generate_primary_key(
                    string_representation(
                        {
                            (
                                entity.external_id,
                                f"{entity.id_type}#{entity.get_class_id_name()}",
                            )
                        }
                    ),
                    state_code,
                )
            )
        else:
            entity.set_id(
                generate_primary_key(
                    json.dumps(
                        serialize_entity_into_json(
                            assert_type(entity, CoreEntity), field_index
                        ),
                        sort_keys=True,
                    ),
                    state_code,
                )
            )

        forward_fields = field_index.get_all_core_entity_fields(
            entity.__class__, EntityFieldType.FORWARD_EDGE
        )
        for field in forward_fields:
            _ = non_optional(
                attr_field_referenced_cls_name_for_field_name(entity.__class__, field)
            )
            queue.extend(entity.get_field_as_list(field))
    return root_entity
